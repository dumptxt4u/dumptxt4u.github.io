<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Enhanced Interactive 3D Solids with Labels, Presets, and Crystalline Structures</title>
    <style>
        body { margin: 0; padding: 20px; font-family: Arial, sans-serif; background: #f0f0f0; }
        #container { width: 100%; height: 600px; border: 1px solid #ccc; position: relative; }
        .controls { margin: 20px 0; }
        .vector-group, .matrix-group, .shape-group { display: inline-block; margin: 10px; padding: 10px; background: white; border-radius: 5px; box-shadow: 0 2px 5px rgba(0,0,0,0.1); }
        label { display: block; margin: 5px 0; }
        input { width: 60px; margin: 0 5px; }
        .matrix-grid { display: grid; grid-template-columns: repeat(3, 1fr); gap: 5px; }
        button { margin: 5px; padding: 8px 16px; background: #007bff; color: white; border: none; border-radius: 5px; cursor: pointer; }
        button:hover { background: #0056b3; }
        .preset-btn { background: #28a745; }
        .preset-btn:hover { background: #218838; }
        .random-btn { background: #ffc107; color: #000; }
        .random-btn:hover { background: #e0a800; }
        select { margin: 5px; padding: 5px; }
        #sphereControls { display: none; }
        .label { color: #000; font: 12px Arial; background: rgba(255,255,255,0.8); padding: 2px 4px; border-radius: 3px; pointer-events: none; }
        #vertexLabels { margin: 10px 0; }
    </style>
</head>
<body>
    <h1>Enhanced 3D Solids: Parallelepipeds, Sphere, and Crystalline Structures</h1>
    <p>Select shape type. For parallelepiped/crystallines, define/use presets for edge vectors. Original in green wireframe, transformed in red. Axes labeled (X-red, Y-green, Z-blue). Grid on XY with numerical labels. Vertex coordinates labeled if enabled. All labels and zoom can be toggled.</p>
    
    <div class="controls">
        <div class="shape-group">
            <h3>Shape Type</h3>
            <select id="shapeType" onchange="toggleControls()">
                <option value="parallelepiped">Parallelepiped/Crystalline</option>
                <option value="sphere">Sphere</option>
            </select>
            <label><input type="checkbox" id="showLabels" checked> Show Vertex Labels</label>
            <label><input type="checkbox" id="showAxisLabels" checked> Show Axis Labels</label>
            <label><input type="checkbox" id="showGridLabels" checked> Show Grid Labels</label>
            <label><input type="checkbox" id="enableZoom" checked> Enable Mouse Wheel Zoom</label>
            <div id="sphereControls">
                <label>Radius: <input type="number" id="radius" value="2" step="0.1"></label>
            </div>
        </div>
    </div>

    <div class="controls" id="vectorControls">
        <div class="vector-group">
            <h3>Vector A (x, y, z)</h3>
            <label>Ax: <input type="number" id="ax" value="2" step="0.1"></label>
            <label>Ay: <input type="number" id="ay" value="0" step="0.1"></label>
            <label>Az: <input type="number" id="az" value="0" step="0.1"></label>
        </div>
        <div class="vector-group">
            <h3>Vector B (x, y, z)</h3>
            <label>Bx: <input type="number" id="bx" value="1" step="0.1"></label>
            <label>By: <input type="number" id="by" value="2" step="0.1"></label>
            <label>Bz: <input type="number" id="bz" value="0" step="0.1"></label>
        </div>
        <div class="vector-group">
            <h3>Vector C (x, y, z)</h3>
            <label>Cx: <input type="number" id="cx" value="0" step="0.1"></label>
            <label>Cy: <input type="number" id="cy" value="1" step="0.1"></label>
            <label>Cz: <input type="number" id="cz" value="2" step="0.1"></label>
        </div>
        <div style="display: inline-block; vertical-align: top; padding: 10px;">
            <button class="preset-btn" onclick="presetCube()">Cube</button>
            <button class="preset-btn" onclick="presetCuboid()">Cuboid</button>
            <button class="preset-btn" onclick="presetRhombohedron()">Rhombohedron</button>
            <button class="preset-btn" onclick="presetFCC()">FCC</button>
            <button class="preset-btn" onclick="presetBCC()">BCC</button>
            <button class="preset-btn" onclick="presetSimpleCubic()">Simple Cubic</button>
        </div>
        <button class="random-btn" onclick="randomVectors()">Random Vectors</button>
    </div>

    <div class="controls">
        <div class="matrix-group">
            <h3>Transformation Matrix (3x3)</h3>
            <div class="matrix-grid">
                <label>M11: <input type="number" id="m11" value="1" step="0.1"></label>
                <label>M12: <input type="number" id="m12" value="0" step="0.1"></label>
                <label>M13: <input type="number" id="m13" value="0" step="0.1"></label>
                <label>M21: <input type="number" id="m21" value="0" step="0.1"></label>
                <label>M22: <input type="number" id="m22" value="1" step="0.1"></label>
                <label>M23: <input type="number" id="m23" value="0" step="0.1"></label>
                <label>M31: <input type="number" id="m31" value="0" step="0.1"></label>
                <label>M32: <input type="number" id="m32" value="0" step="0.1"></label>
                <label>M33: <input type="number" id="m33" value="1" step="0.1"></label>
            </div>
        </div>
        <button class="random-btn" onclick="randomMatrix()">Random Matrix</button>
        <button onclick="updateSolid()">Update Solid</button>
        <button onclick="resetAll()">Reset</button>
    </div>
    
    <div id="container"></div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/renderers/CSS2DRenderer.js"></script>
    <script>
        let scene, camera, renderer, labelRenderer, controls, meshOriginal, meshTransformed, axesHelper, gridHelper;
        let labelOriginal = [], labelTransformed = [], axisLabels = [], gridLabels = [];

        function init() {
            const container = document.getElementById('container');

            // Scene setup
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0xeeeeee);

            // Camera
            camera = new THREE.PerspectiveCamera(75, container.clientWidth / 600, 0.1, 1000);
            camera.position.set(8, 8, 8);

            // Renderer
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(container.clientWidth, 600);
            container.appendChild(renderer.domElement);

            // Label Renderer
            labelRenderer = new THREE.CSS2DRenderer();
            labelRenderer.setSize(container.clientWidth, 600);
            labelRenderer.domElement.style.position = 'absolute';
            labelRenderer.domElement.style.top = '0';
            container.appendChild(labelRenderer.domElement);

            // Controls
            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.enableZoom = document.getElementById('enableZoom').checked;

            // Lighting
            const ambientLight = new THREE.AmbientLight(0x404040, 0.6);
            scene.add(ambientLight);
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(10, 10, 5);
            scene.add(directionalLight);

            // Reference axes
            axesHelper = new THREE.AxesHelper(10);
            scene.add(axesHelper);

            // Grid
            gridHelper = new THREE.GridHelper(10, 10, 0x888888, 0xcccccc);
            scene.add(gridHelper);

            // Initial setup
            createAxisLabels();
            createGridLabels();
            toggleAxisLabels(document.getElementById('showAxisLabels').checked);
            toggleGridLabels(document.getElementById('showGridLabels').checked);
            toggleControls();
            updateSolid();

            // Animation loop
            animate();

            // Event listeners for live updates
            document.querySelectorAll('input[type="number"]').forEach(el => el.addEventListener('input', updateSolid));
            document.getElementById('shapeType').addEventListener('change', () => { toggleControls(); updateSolid(); });
            document.getElementById('showLabels').addEventListener('change', updateSolid);
            document.getElementById('showAxisLabels').addEventListener('change', (e) => toggleAxisLabels(e.target.checked));
            document.getElementById('showGridLabels').addEventListener('change', (e) => toggleGridLabels(e.target.checked));
            document.getElementById('enableZoom').addEventListener('change', (e) => { controls.enableZoom = e.target.checked; });
        }

        function createLabel(text) {
            const div = document.createElement('div');
            div.className = 'label';
            div.textContent = text;
            div.style.marginTop = '-1em';
            return new THREE.CSS2DObject(div);
        }

        function createAxisLabels() {
            const xLabel = createLabel('X');
            xLabel.position.set(10.5, 0, 0);
            scene.add(xLabel);
            axisLabels.push(xLabel);

            const yLabel = createLabel('Y');
            yLabel.position.set(0, 10.5, 0);
            scene.add(yLabel);
            axisLabels.push(yLabel);

            const zLabel = createLabel('Z');
            zLabel.position.set(0, 0, 10.5);
            scene.add(zLabel);
            axisLabels.push(zLabel);
        }

        function createGridLabels() {
            // X axis labels
            for (let i = -5; i <= 5; i++) {
                if (i === 0) continue;
                const label = createLabel(i.toString());
                label.position.set(i, -0.5, 0);
                scene.add(label);
                gridLabels.push(label);
            }
            // Y axis labels
            for (let i = -5; i <= 5; i++) {
                if (i === 0) continue;
                const label = createLabel(i.toString());
                label.position.set(-0.5, i, 0);
                scene.add(label);
                gridLabels.push(label);
            }
            // 0 label at origin
            const zeroLabel = createLabel('0');
            zeroLabel.position.set(-0.3, -0.3, 0);
            scene.add(zeroLabel);
            gridLabels.push(zeroLabel);
        }

        function toggleAxisLabels(show) {
            axisLabels.forEach(l => l.element.style.display = show ? 'block' : 'none');
        }

        function toggleGridLabels(show) {
            gridLabels.forEach(l => l.element.style.display = show ? 'block' : 'none');
        }

        function clearLabels(type) {
            if (type === 'vertex') {
                labelOriginal.forEach(l => scene.remove(l));
                labelTransformed.forEach(l => scene.remove(l));
                labelOriginal = [];
                labelTransformed = [];
            }
        }

        function addVertexLabels(vectors, labelArray) {
            vectors.forEach(v => {
                const label = createLabel(`(${v.x.toFixed(1)}, ${v.y.toFixed(1)}, ${v.z.toFixed(1)})`);
                label.position.copy(v);
                scene.add(label);
                labelArray.push(label);
            });
        }

        function toggleControls() {
            const type = document.getElementById('shapeType').value;
            document.getElementById('vectorControls').style.display = type === 'parallelepiped' ? 'block' : 'none';
            document.getElementById('sphereControls').style.display = type === 'sphere' ? 'block' : 'none';
        }

        function createGeometry(vectors) {
            const geometry = new THREE.BufferGeometry();
            const positions = new Float32Array(24); // 8 * 3
            vectors.forEach((v, i) => {
                positions[i * 3] = v.x;
                positions[i * 3 + 1] = v.y;
                positions[i * 3 + 2] = v.z;
            });
            geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
            const indices = [
                0, 1, 4, 0, 4, 2,
                3, 5, 7, 3, 7, 6,
                0, 1, 5, 0, 5, 3,
                0, 2, 6, 0, 6, 3,
                1, 4, 7, 1, 7, 5,
                2, 4, 7, 2, 7, 6
            ];
            geometry.setIndex(indices);
            geometry.computeVertexNormals();
            return geometry;
        }

        function updateSolid() {
            const type = document.getElementById('shapeType').value;
            const showLabels = document.getElementById('showLabels').checked;

            clearLabels('vertex');

            if (meshOriginal) scene.remove(meshOriginal);
            if (meshTransformed) scene.remove(meshTransformed);

            // Matrix (common to both shapes)
            const m11 = parseFloat(document.getElementById('m11').value) || 0;
            const m12 = parseFloat(document.getElementById('m12').value) || 0;
            const m13 = parseFloat(document.getElementById('m13').value) || 0;
            const m21 = parseFloat(document.getElementById('m21').value) || 0;
            const m22 = parseFloat(document.getElementById('m22').value) || 0;
            const m23 = parseFloat(document.getElementById('m23').value) || 0;
            const m31 = parseFloat(document.getElementById('m31').value) || 0;
            const m32 = parseFloat(document.getElementById('m32').value) || 0;
            const m33 = parseFloat(document.getElementById('m33').value) || 0;

            const matrix = new THREE.Matrix3().set(
                m11, m12, m13,
                m21, m22, m23,
                m31, m32, m33
            );

            if (type === 'parallelepiped') {
                // Vectors
                const ax = parseFloat(document.getElementById('ax').value) || 0;
                const ay = parseFloat(document.getElementById('ay').value) || 0;
                const az = parseFloat(document.getElementById('az').value) || 0;
                const bx = parseFloat(document.getElementById('bx').value) || 0;
                const by = parseFloat(document.getElementById('by').value) || 0;
                const bz = parseFloat(document.getElementById('bz').value) || 0;
                const cx = parseFloat(document.getElementById('cx').value) || 0;
                const cy = parseFloat(document.getElementById('cy').value) || 0;
                const cz = parseFloat(document.getElementById('cz').value) || 0;

                const vectors = [
                    new THREE.Vector3(0, 0, 0),
                    new THREE.Vector3(ax, ay, az),
                    new THREE.Vector3(bx, by, bz),
                    new THREE.Vector3(cx, cy, cz),
                    new THREE.Vector3(ax + bx, ay + by, az + bz),
                    new THREE.Vector3(ax + cx, ay + cy, az + cz),
                    new THREE.Vector3(bx + cx, by + cy, bz + cz),
                    new THREE.Vector3(ax + bx + cx, ay + by + cy, az + bz + cz)
                ];

                // Original
                const geoOriginal = createGeometry(vectors);
                const materialOriginal = new THREE.MeshLambertMaterial({ 
                    color: 0x44aa88, side: THREE.DoubleSide, transparent: true, opacity: 0.6, wireframe: true 
                });
                meshOriginal = new THREE.Mesh(geoOriginal, materialOriginal);
                scene.add(meshOriginal);

                if (showLabels) addVertexLabels(vectors, labelOriginal);

                // Transformed
                const vectorsT = vectors.map(v => v.clone().applyMatrix3(matrix));

                const geoTransformed = createGeometry(vectorsT);
                const materialTransformed = new THREE.MeshLambertMaterial({ 
                    color: 0xaa4444, side: THREE.DoubleSide, transparent: true, opacity: 0.8 
                });
                meshTransformed = new THREE.Mesh(geoTransformed, materialTransformed);
                scene.add(meshTransformed);

                if (showLabels) addVertexLabels(vectorsT, labelTransformed);

            } else if (type === 'sphere') {
                const radius = parseFloat(document.getElementById('radius').value) || 2;

                // Original sphere
                const geoOriginal = new THREE.SphereGeometry(radius, 32, 16);
                const materialOriginal = new THREE.MeshLambertMaterial({ 
                    color: 0x44aa88, side: THREE.DoubleSide, transparent: true, opacity: 0.6, wireframe: true 
                });
                meshOriginal = new THREE.Mesh(geoOriginal, materialOriginal);
                scene.add(meshOriginal);

                // For labels, add center
                if (showLabels) {
                    const centerLabel = createLabel('(0, 0, 0)');
                    centerLabel.position.set(0, 0, 0);
                    scene.add(centerLabel);
                    labelOriginal.push(centerLabel);
                }

                // Transformed (ellipsoid)
                const positions = geoOriginal.attributes.position.array;
                const transformedPositions = new Float32Array(positions.length);
                for (let i = 0; i < positions.length / 3; i++) {
                    const x = positions[i * 3];
                    const y = positions[i * 3 + 1];
                    const z = positions[i * 3 + 2];
                    const vec = new THREE.Vector3(x, y, z);
                    vec.applyMatrix3(matrix);
                    transformedPositions[i * 3] = vec.x;
                    transformedPositions[i * 3 + 1] = vec.y;
                    transformedPositions[i * 3 + 2] = vec.z;
                }
                const geoTransformed = new THREE.BufferGeometry().copy(geoOriginal);
                geoTransformed.setAttribute('position', new THREE.Float32BufferAttribute(transformedPositions, 3));
                geoTransformed.computeVertexNormals();
                const materialTransformed = new THREE.MeshLambertMaterial({ 
                    color: 0xaa4444, side: THREE.DoubleSide, transparent: true, opacity: 0.8 
                });
                meshTransformed = new THREE.Mesh(geoTransformed, materialTransformed);
                scene.add(meshTransformed);

                // No vertex labels for sphere (too many), but add transformed center if desired
                if (showLabels) {
                    const centerLabelT = createLabel('(0, 0, 0)');
                    centerLabelT.position.set(0, 0, 0);
                    scene.add(centerLabelT);
                    labelTransformed.push(centerLabelT);
                }
            }

            // Fit view
            const box = new THREE.Box3();
            if (meshOriginal) box.union(new THREE.Box3().setFromObject(meshOriginal));
            if (meshTransformed) box.union(new THREE.Box3().setFromObject(meshTransformed));
            if (!box.isEmpty()) {
                const center = box.getCenter(new THREE.Vector3());
                const size = box.getSize(new THREE.Vector3());
                const maxDim = Math.max(size.x, size.y, size.z);
                const fov = camera.fov * (Math.PI / 180);
                let cameraDist = Math.abs(maxDim / Math.sin(fov / 2));
                cameraDist *= 1.2; // padding
                camera.position.copy(center).add(new THREE.Vector3(1, 1, 1).normalize().multiplyScalar(cameraDist));
                camera.lookAt(center);
                controls.target.copy(center);
                controls.update();
            }
        }

        // Preset functions
        function presetCube() {
            document.getElementById('ax').value = '1'; document.getElementById('ay').value = '0'; document.getElementById('az').value = '0';
            document.getElementById('bx').value = '0'; document.getElementById('by').value = '1'; document.getElementById('bz').value = '0';
            document.getElementById('cx').value = '0'; document.getElementById('cy').value = '0'; document.getElementById('cz').value = '1';
            updateSolid();
        }

        function presetCuboid() {
            document.getElementById('ax').value = '2'; document.getElementById('ay').value = '0'; document.getElementById('az').value = '0';
            document.getElementById('bx').value = '0'; document.getElementById('by').value = '1.5'; document.getElementById('bz').value = '0';
            document.getElementById('cx').value = '0'; document.getElementById('cy').value = '0'; document.getElementById('cz').value = '3';
            updateSolid();
        }

        function presetRhombohedron() {
            const alpha = Math.PI / 3; // 60 degrees
            const a = 1;
            document.getElementById('ax').value = a.toFixed(2); document.getElementById('ay').value = '0.00'; document.getElementById('az').value = '0.00';
            document.getElementById('bx').value = (a * Math.cos(alpha)).toFixed(2); document.getElementById('by').value = (a * Math.sin(alpha)).toFixed(2); document.getElementById('bz').value = '0.00';
            const x3 = a * Math.cos(alpha);
            const y3 = a * Math.cos(alpha) * (1 - Math.cos(alpha)) / Math.sin(alpha);
            const z3 = Math.sqrt(a**2 - x3**2 - y3**2);
            document.getElementById('cx').value = x3.toFixed(2); document.getElementById('cy').value = y3.toFixed(2); document.getElementById('cz').value = z3.toFixed(2);
            updateSolid();
        }

        function presetFCC() {
            const scale = 1;
            document.getElementById('ax').value = '0.00'; document.getElementById('ay').value = (0.5*scale).toFixed(2); document.getElementById('az').value = (0.5*scale).toFixed(2);
            document.getElementById('bx').value = (0.5*scale).toFixed(2); document.getElementById('by').value = '0.00'; document.getElementById('bz').value = (0.5*scale).toFixed(2);
            document.getElementById('cx').value = (0.5*scale).toFixed(2); document.getElementById('cy').value = (0.5*scale).toFixed(2); document.getElementById('cz').value = '0.00';
            updateSolid();
        }

        function presetBCC() {
            const scale = 1;
            document.getElementById('ax').value = (0.5*scale).toFixed(2); document.getElementById('ay').value = (0.5*scale).toFixed(2); document.getElementById('az').value = (-0.5*scale).toFixed(2);
            document.getElementById('bx').value = (-0.5*scale).toFixed(2); document.getElementById('by').value = (0.5*scale).toFixed(2); document.getElementById('bz').value = (0.5*scale).toFixed(2);
            document.getElementById('cx').value = (0.5*scale).toFixed(2); document.getElementById('cy').value = (-0.5*scale).toFixed(2); document.getElementById('cz').value = (0.5*scale).toFixed(2);
            updateSolid();
        }

        function presetSimpleCubic() {
            presetCube(); // Same as cube with a=1
        }

        function randomVectors() {
            document.getElementById('ax').value = (Math.random() * 4 - 2).toFixed(1);
            document.getElementById('ay').value = (Math.random() * 4 - 2).toFixed(1);
            document.getElementById('az').value = (Math.random() * 4 - 2).toFixed(1);
            document.getElementById('bx').value = (Math.random() * 4 - 2).toFixed(1);
            document.getElementById('by').value = (Math.random() * 4 - 2).toFixed(1);
            document.getElementById('bz').value = (Math.random() * 4 - 2).toFixed(1);
            document.getElementById('cx').value = (Math.random() * 4 - 2).toFixed(1);
            document.getElementById('cy').value = (Math.random() * 4 - 2).toFixed(1);
            document.getElementById('cz').value = (Math.random() * 4 - 2).toFixed(1);
            updateSolid();
        }

        function randomMatrix() {
            ['m11','m12','m13','m21','m22','m23','m31','m32','m33'].forEach(id => {
                document.getElementById(id).value = (Math.random() * 2 - 1).toFixed(1);
            });
            updateSolid();
        }

        function resetAll() {
            presetCuboid();
            ['m11','m12','m13','m21','m22','m23','m31','m32','m33'].forEach(id => {
                document.getElementById(id).value = id === 'm11' || id === 'm22' || id === 'm33' ? '1' : '0';
            });
            document.getElementById('shapeType').value = 'parallelepiped';
            toggleControls();
            updateSolid();
        }

        function animate() {
            requestAnimationFrame(animate);
            controls.update();
            renderer.render(scene, camera);
            labelRenderer.render(scene, camera);
        }

        window.addEventListener('resize', () => {
            const container = document.getElementById('container');
            camera.aspect = container.clientWidth / 600;
            camera.updateProjectionMatrix();
            renderer.setSize(container.clientWidth, 600);
            labelRenderer.setSize(container.clientWidth, 600);
        });

        init();
    </script>
</body>
</html>
